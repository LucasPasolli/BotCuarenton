(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Translator = factory());
}(this, (function () { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var Translator = /*#__PURE__*/function () {
    _createClass(Translator, [{
      key: "translation",

      /**
       *
       * @return {Object}
       */
      get: function get() {
        if (this.translations[this.locale] !== undefined) {
          return this.translations[this.locale];
        }

        if (this.translations[this.localeArea] !== undefined) {
          return this.translations[this.localeArea];
        }

        if (this.translations[this.localeDefault] !== undefined) {
          return this.translations[this.localeDefault];
        }

        return {};
      }
      /**
       * @param {Object} translations
       * @param {BBCode} [bbCodeParser]
       * @param {String} [locale]
       * @param {String} [localeArea]
       * @param {String} [localeDefault]
       * @param {RegExp} [regexpParameters]
       * @param {RegExp} [regexpTranslations]
       */

    }]);

    function Translator(translations, _ref) {
      var _ref$bbCodeParser = _ref.bbCodeParser,
          bbCodeParser = _ref$bbCodeParser === void 0 ? undefined : _ref$bbCodeParser,
          _ref$locale = _ref.locale,
          locale = _ref$locale === void 0 ? 'en-GB' : _ref$locale,
          _ref$localeArea = _ref.localeArea,
          localeArea = _ref$localeArea === void 0 ? 'en-GB' : _ref$localeArea,
          _ref$localeDefault = _ref.localeDefault,
          localeDefault = _ref$localeDefault === void 0 ? 'en-GB' : _ref$localeDefault,
          _ref$regexpParameters = _ref.regexpParameters,
          regexpParameters = _ref$regexpParameters === void 0 ? /\\?\[([^\[\]]+)\]/g : _ref$regexpParameters,
          _ref$regexpTranslatio = _ref.regexpTranslations,
          regexpTranslations = _ref$regexpTranslatio === void 0 ? /[\\\$]?\{([^{}]+)\}/g : _ref$regexpTranslatio;

      _classCallCheck(this, Translator);

      /**
       * all translations in structure. structure is
       *    LOCALE:
       *        TRKEY => VALUE
       *        ...
       *
       * TRKEY is defined bei "TRFILE.TRINDEX" given from backend
       *
       * @var {Object}
       */
      this.translations = {};
      this.bbCodeParser = bbCodeParser;
      this.locale = locale;
      this.localeArea = localeArea;
      this.localeDefault = localeDefault;
      this.regexpParameters = regexpParameters;
      this.regexpTranslations = regexpTranslations;
      this.setTranslations(translations);
    }
    /**
     *
     * @param {String} key
     * @param {String} [defaults]
     * @return {*}
     */


    _createClass(Translator, [{
      key: "getValueFromKey",
      value: function getValueFromKey(key, defaults) {
        var keys = key.split('.');
        var text = keys.reduce(function (acc, entry) {
          var _acc$entry;

          return (_acc$entry = acc[entry]) !== null && _acc$entry !== void 0 ? _acc$entry : undefined;
        }, this.translation);

        if (text === undefined && this.translations[this.localeArea] !== undefined) {
          text = keys.reduce(function (acc, entry) {
            var _acc$entry2;

            return (_acc$entry2 = acc[entry]) !== null && _acc$entry2 !== void 0 ? _acc$entry2 : undefined;
          }, this.translations[this.localeArea]);
        }

        if (text === undefined && this.translations[this.localeDefault] !== undefined) {
          text = keys.reduce(function (acc, entry) {
            var _acc$entry3;

            return (_acc$entry3 = acc[entry]) !== null && _acc$entry3 !== void 0 ? _acc$entry3 : undefined;
          }, this.translations[this.localeDefault]);
        }

        if (text === undefined) {
          if (defaults === undefined) {
            return '{' + key + '}';
          }

          text = defaults;
        }

        return text;
      }
      /**
       *
       * @param {BBCode} bbCodeParser
       * @return {Translator}
       */

    }, {
      key: "setBBCodeParser",
      value: function setBBCodeParser(bbCodeParser) {
        this.bbCodeParser = bbCodeParser;
        return this;
      }
      /**
       * set Translations
       *
       * @param {Object} translations
       * @returns {Translator}
       */

    }, {
      key: "setTranslations",
      value: function setTranslations(translations) {
        var _this = this;

        Object.entries(translations).forEach(function (_ref2) {
          var _ref3 = _slicedToArray(_ref2, 2),
              locale = _ref3[0],
              values = _ref3[1];

          if (_this.translations[locale] === undefined) {
            _this.translations[locale] = {};
          }

          _this.translations[locale] = _objectSpread2({}, values);
        });
        return this;
      }
      /**
       * translate a text with given parameters
       *
       * @param {String} key
       * @param {Object} [parameters]
       * @param {String} [defaults]
       * @returns {String}
       */

    }, {
      key: "translate",
      value: function translate(key, parameters, defaults) {
        if (key === undefined || key === null) {
          return key;
        }

        if (key.charAt(0) === '{') {
          key = key.slice(1);
        }

        if (key.charAt(key.length - 1) === '}') {
          key = key.slice(0, key.length - 1);
        }

        var text = this.getValueFromKey(key, defaults);

        if (text === null || text === undefined) {
          return text;
        }

        if (typeof text !== 'string') {
          return text;
        } // parameter replacement


        if (parameters instanceof Object) {
          text = Object.keys(parameters).reduce(function (acc, name) {
            return acc.replace(new RegExp('\\[' + name + '\\]', 'gi'), parameters[name]);
          }, text);
        }

        if (this.bbCodeParser === undefined) {
          return text;
        }

        return this.bbCodeParser.parse(text);
      }
    }, {
      key: "translateInline",

      /**
       * inline translation
       *
       * @param {String} text
       * @returns {String}
       */
      value: function translateInline(text) {
        var _this2 = this;

        // replace the text
        text = text.replace(this.regexpTranslations, function (match, key) {
          switch (match.charAt(0)) {
            case '\\':
              return match.slice(1);

            case '$':
              return match;
          }

          return _this2.translate(key, undefined, match);
        });
        return text;
      }
    }]);

    return Translator;
  }();

  return Translator;

})));
//# sourceMappingURL=translator.js.map
